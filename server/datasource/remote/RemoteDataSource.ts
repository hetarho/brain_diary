import {
  PrismaClient,
  User,
  Entry,
  Engram,
  Synapse,
  MemoryType,
  Provider,
  Prisma,
  EmotionTag,
  EmotionType,
} from "@prisma/client";

// --- Domain-Level Types ---
// These types define the data structures for the application layer,
// independent of the database implementation (Prisma).

// Complex types for responses with relations
export type EntryWithEngramsAndCount = Entry & {
  engrams: Engram[];
  _count: {
    engrams: number;
  };
};

export type DeletedEntryWithCount = Entry & {
  _count: {
    engrams: number;
  };
};

export type SynapseWithToEngram = Synapse & {
  toEngram: Engram & {
    user: User;
    emotionTags: EmotionTag[];
  };
};

export type SynapseWithFromEngram = Synapse & {
  fromEngram: Engram & {
    user: User;
    emotionTags: EmotionTag[];
  };
};

// --- Input DTOs (Data Transfer Objects) ---
// These types define the shape of data for create/update operations.
// They no longer contain fields that should be generated by the database
// or data layer, like `id` or `createdAt`.

export type CreateUserInput = {
  email: string;
  provider: Provider;
  providerId: string;
  name: string;
  image?: string | null;
};
export type CreateEntryInput = {
  userId: string;
  content: string;
};

// Represents the core data for an engram, typically from the LLM.
export type EngramCoreData = {
  content: string;
  category: MemoryType;
  importance: number;
  currentStrength: number;
  keywords: string[];
};

// The input for creating an engram in the data source.
export type CreateEngramInput = EngramCoreData & {
  userId: string;
  entryId: string;
};

// EmotionTag related types
export type CreateEmotionTagInput = {
  engramId: string;
  emotion: EmotionType;
  intensity: number;
  valence: number;
  arousal: number;
};

export type SynapseType = "SEMANTIC" | "EMOTIONAL" | "TEMPORAL" | "ASSOCIATIVE";

export type CreateSynapseInput = {
  fromEngramId: string;
  toEngramId: string;
  strength: number;
  type: SynapseType;
};

export type CreateManySynapsesInput = {
  synapses: CreateSynapseInput[];
  skipDuplicates?: boolean;
};

export type BatchPayload = {
  count: number;
};

// A safe, abstracted type for querying engrams.
export type EngramQueryWhereInput = {
  userId: string;
  id?: {
    not?: string;
    in?: string[];
  };
};

// --- Remote Data Source Interface ---
// This interface is now completely decoupled from Prisma's operational types.

export interface RemoteDataSource {
  // User methods
  findUserByEmail(email: string): Promise<User | null>;
  createUser(data: CreateUserInput): Promise<User>;
  getUser(userId: string): Promise<User | null>;

  // Entry methods
  createEntry(data: CreateEntryInput): Promise<Entry>;
  getEntriesByUser(userId: string): Promise<EntryWithEngramsAndCount[]>;
  deleteEntry(entryId: string): Promise<DeletedEntryWithCount>;

  // Engram methods
  createEngram(data: CreateEngramInput): Promise<Engram>;
  findEngramById(id: string): Promise<Engram | null>;
  findEngrams(where: EngramQueryWhereInput): Promise<Engram[]>;
  findEngramsByUser(userId: string): Promise<Engram[]>;
  findEngramsByEntry(entryId: string): Promise<Engram[]>;
  rehearseEngram(id: string): Promise<Engram>;

  // EmotionTag methods
  createEmotionTag(data: CreateEmotionTagInput): Promise<EmotionTag>;
  getEmotionTagsByEngram(engramId: string): Promise<EmotionTag[]>;

  // Synapse methods
  createManySynapses(data: CreateManySynapsesInput): Promise<BatchPayload>;
  getOutgoingSynapses(
    engramId: string,
    minStrength: number
  ): Promise<SynapseWithToEngram[]>;
  getIncomingSynapses(
    engramId: string,
    minStrength: number
  ): Promise<SynapseWithFromEngram[]>;
  strengthenSynapses(engramId: string): Promise<BatchPayload>;
  findUniqueSynapse(
    fromEngramId: string,
    toEngramId: string
  ): Promise<Synapse | null>;
  createSynapse(data: CreateSynapseInput): Promise<Synapse>;
}

// --- Prisma-based Implementation ---
// This class implements the RemoteDataSource interface and uses Prisma
// to interact with the database. It handles mapping between domain types and Prisma types.
class RemoteDataSourceImpl implements RemoteDataSource {
  constructor(private readonly prisma: PrismaClient) {}

  // User methods
  async findUserByEmail(email: string): Promise<User | null> {
    return this.prisma.user.findFirst({
      where: { email },
    });
  }

  async createUser(data: CreateUserInput): Promise<User> {
    return this.prisma.user.create({ data });
  }

  async getUser(userId: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { id: userId },
    });
  }

  // Entry methods
  async createEntry(data: CreateEntryInput): Promise<Entry> {
    return this.prisma.entry.create({ data });
  }

  async getEntriesByUser(userId: string): Promise<EntryWithEngramsAndCount[]> {
    return this.prisma.entry.findMany({
      where: { userId },
      include: {
        engrams: true,
        _count: {
          select: { engrams: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });
  }

  async deleteEntry(entryId: string): Promise<DeletedEntryWithCount> {
    return this.prisma.entry.delete({
      where: { id: entryId },
      include: {
        _count: {
          select: { engrams: true },
        },
      },
    });
  }

  // Engram methods
  async createEngram(data: CreateEngramInput): Promise<Engram> {
    return this.prisma.engram.create({
      data: {
        content: data.content,
        category: data.category,
        importance: data.importance,
        currentStrength: data.currentStrength,
        keywords: data.keywords,
        userId: data.userId,
        entryId: data.entryId,
        rehearsalCount: 0,
        consolidationState: "FRESH",
        lastActivatedAt: new Date(),
        decayRate: 0.1,
      },
    });
  }

  async findEngramById(id: string): Promise<Engram | null> {
    return this.prisma.engram.findUnique({
      where: { id },
    });
  }

  async findEngrams(where: EngramQueryWhereInput): Promise<Engram[]> {
    // The `where` clause is compatible with Prisma's `EngramWhereInput`
    // for the specific properties we've defined in `EngramQueryWhereInput`.
    // Casting to `Prisma.EngramWhereInput` provides better type safety than `any`.
    return this.prisma.engram.findMany({
      where: where as Prisma.EngramWhereInput,
    });
  }

  async findEngramsByUser(userId: string): Promise<Engram[]> {
    return this.prisma.engram.findMany({
      where: { userId },
      include: {
        emotionTags: true
      },
      orderBy: { createdAt: "desc" },
    });
  }

  async findEngramsByEntry(entryId: string): Promise<Engram[]> {
    return this.prisma.engram.findMany({
      where: { entryId },
      include: {
        emotionTags: true
      },
      orderBy: { createdAt: "desc" },
    });
  }

  async rehearseEngram(id: string): Promise<Engram> {
    return this.prisma.engram.update({
      where: { id },
      data: {
        rehearsalCount: { increment: 1 },
        importance: { increment: 0.1 },
        updatedAt: new Date(),
      },
    });
  }

  // EmotionTag methods
  async createEmotionTag(data: CreateEmotionTagInput): Promise<EmotionTag> {
    return this.prisma.emotionTag.create({ data });
  }

  async getEmotionTagsByEngram(engramId: string): Promise<EmotionTag[]> {
    return this.prisma.emotionTag.findMany({
      where: { engramId },
    });
  }

  // Synapse methods
  async createManySynapses(
    data: CreateManySynapsesInput
  ): Promise<BatchPayload> {
    return this.prisma.synapse.createMany({
      data: data.synapses,
      skipDuplicates: data.skipDuplicates,
    });
  }

  async getOutgoingSynapses(
    engramId: string,
    minStrength: number
  ): Promise<SynapseWithToEngram[]> {
    return this.prisma.synapse.findMany({
      where: {
        fromEngramId: engramId,
        strength: { gte: minStrength },
      },
      include: {
        toEngram: {
          include: {
            user: true,
            emotionTags: true
          },
        },
      },
      orderBy: { strength: "desc" },
    });
  }

  async getIncomingSynapses(
    engramId: string,
    minStrength: number
  ): Promise<SynapseWithFromEngram[]> {
    return this.prisma.synapse.findMany({
      where: {
        toEngramId: engramId,
        strength: { gte: minStrength },
      },
      include: {
        fromEngram: {
          include: {
            user: true,
            emotionTags: true
          },
        },
      },
      orderBy: { strength: "desc" },
    });
  }

  async strengthenSynapses(engramId: string): Promise<BatchPayload> {
    return this.prisma.synapse.updateMany({
      where: {
        OR: [{ fromEngramId: engramId }, { toEngramId: engramId }],
      },
      data: {
        strength: {
          increment: 0.05,
        },
      },
    });
  }

  async findUniqueSynapse(
    fromEngramId: string,
    toEngramId: string
  ): Promise<Synapse | null> {
    return this.prisma.synapse.findUnique({
      where: {
        fromEngramId_toEngramId: {
          fromEngramId,
          toEngramId,
        },
      },
    });
  }

  async createSynapse(data: CreateSynapseInput): Promise<Synapse> {
    return this.prisma.synapse.create({ data });
  }
}

export default RemoteDataSourceImpl;
